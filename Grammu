-- COCO HUB | Delta Full Version | ArrayField UI
-- Features: Aimbot, SilentAim, ESP (box+HP), Hitbox expand (others), Self Hand Hitbox, Movement (Walk/Jump/Fly/NoClip), Invisible
-- Note: Combat/ESP toggles default OFF. FOV shows only when Aimbot or SilentAim ON.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ================= State =================
local State = {
    -- Combat / Aim
    Aimbot=false,
    SilentAim=false,
    AimbotPart="Head",
    FOVRadius=120,
    FOVRainbow=false,

    -- ESP / Hitbox (other players)
    ESP=false,
    TargetESP=false,
    ESPColor=Color3.fromRGB(255,0,0),
    Hitbox=false,
    HitboxSize=10,
    HitboxColor=Color3.fromRGB(0,255,0),

    -- Self hand hitbox
    SelfHandHitbox=false,
    HandTarget="Both", -- "Both","Right","Left"
    HandHitboxSize=6, -- size scalar (uniform scaling or size value)

    -- Movement
    WalkSpeed=16,
    JumpPower=50,
    Fly=false,
    FlySpeed=40,
    NoClip=false,

    -- Misc
    Invisible=false
}

-- ================= Helpers =================
local safeDrawing = {}
do
    local ok, DrawingLib = pcall(function() return Drawing end)
    safeDrawing.available = ok and DrawingLib~=nil
end

local function newDrawing(kind, props)
    if not safeDrawing.available then return nil end
    local ok,obj = pcall(function() return Drawing.new(kind) end)
    if not ok or not obj then return nil end
    if props then for k,v in pairs(props) do pcall(function() obj[k]=v end) end end
    return obj
end

local function isR15(char)
    return char:FindFirstChild("RightLowerArm") ~= nil or char:FindFirstChild("RightHand") ~= nil
end

-- ================= Store original sizes/state =================
local OriginalHitboxes = {} -- [player] = Vector3
local function storeOriginalHitbox(plr)
    if not plr or not plr.Character then return end
    local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
    if hrp then OriginalHitboxes[plr] = OriginalHitboxes[plr] or hrp.Size end
end
local function restoreOriginalHitbox(plr)
    if not plr or not plr.Character then return end
    local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
    if hrp and OriginalHitboxes[plr] then
        pcall(function() hrp.Size = OriginalHitboxes[plr]; hrp.CanCollide = false end)
        OriginalHitboxes[plr] = nil
    end
end

-- Self hand original sizes
local OriginalHandSizes = {} -- [char] = {Left=Vector3, Right=Vector3, LeftName,RightName}
local function storeOriginalHandSizes(char)
    if not char then return end
    if OriginalHandSizes[char] then return end
    local leftName, rightName
    if char:FindFirstChild("LeftHand") then leftName="LeftHand" end
    if char:FindFirstChild("RightHand") then rightName="RightHand" end
    -- for R6
    if not leftName and char:FindFirstChild("Left Arm") then leftName="Left Arm" end
    if not rightName and char:FindFirstChild("Right Arm") then rightName="Right Arm" end
    OriginalHandSizes[char] = {Left=nil,Right=nil,LeftName=leftName,RightName=rightName}
    if leftName and char:FindFirstChild(leftName) and char[leftName]:IsA("BasePart") then
        OriginalHandSizes[char].Left = char[leftName].Size
    end
    if rightName and char:FindFirstChild(rightName) and char[rightName]:IsA("BasePart") then
        OriginalHandSizes[char].Right = char[rightName].Size
    end
end
local function restoreOriginalHandSizes(char)
    if not char or not OriginalHandSizes[char] then return end
    local info = OriginalHandSizes[char]
    if info.LeftName and info.Left and char:FindFirstChild(info.LeftName) and char[info.LeftName]:IsA("BasePart") then
        pcall(function() char[info.LeftName].Size = info.Left; char[info.LeftName].CanCollide = false end)
    end
    if info.RightName and info.Right and char:FindFirstChild(info.RightName) and char[info.RightName]:IsA("BasePart") then
        pcall(function() char[info.RightName].Size = info.Right; char[info.RightName].CanCollide = false end)
    end
    OriginalHandSizes[char] = nil
end

-- Ensure restore when player leaves
Players.PlayerRemoving:Connect(function(plr)
    OriginalHitboxes[plr] = nil
end)

-- ================= ArrayField UI =================
local ArrayField = loadstring(game:HttpGet("https://raw.githubusercontent.com/Hosvile/Refinement/main/MC%3AArrayfield%20Library"))()
local Window = ArrayField:CreateWindow({ Name="COCO HUB | Delta Pro Ultimate", LoadingTitle="COCO HUB Loading", ConfigurationSaving={Enabled=true,FileName="COCO_HUB_Delta"}, KeySystem=false })

local CombatTab = Window:CreateTab("Combat")
local MoveTab = Window:CreateTab("Movement")
local ESPTab = Window:CreateTab("ESP")
local MiscTab = Window:CreateTab("Misc")

-- ================= UI Elements =================
-- Combat
local AimbotToggle = CombatTab:CreateToggle({Name="Aimbot", CurrentValue=State.Aimbot, Callback=function(v) State.Aimbot=v end})
local SilentAimToggle = CombatTab:CreateToggle({Name="Silent Aim", CurrentValue=State.SilentAim, Callback=function(v) State.SilentAim=v end})
local AimbotPartDropdown = CombatTab:CreateDropdown({Name="Aimbot Part", Options={"Head","HumanoidRootPart"}, CurrentOption=State.AimbotPart, MultiSelection=false, Callback=function(v) State.AimbotPart=v end})
local FOVSlider = CombatTab:CreateSlider({Name="FOV Radius", Range={50,1000}, Increment=1, CurrentValue=State.FOVRadius, Callback=function(v) State.FOVRadius=v end})
local RainbowFOVToggle = CombatTab:CreateToggle({Name="Rainbow FOV", CurrentValue=State.FOVRainbow, Callback=function(v) State.FOVRainbow=v end})
local HitboxToggle = CombatTab:CreateToggle({Name="Hitbox Expand", CurrentValue=State.Hitbox, Callback=function(v)
    State.Hitbox=v
    if not v then
        -- restore others' HRP
        for _,plr in pairs(Players:GetPlayers()) do if plr~=LocalPlayer then restoreOriginalHitbox(plr) end end
    else
        for _,plr in pairs(Players:GetPlayers()) do if plr~=LocalPlayer then storeOriginalHitbox(plr) end end
    end
end})
local HitboxSizeSlider = CombatTab:CreateSlider({Name="Hitbox Size", Range={10,500}, Increment=1, CurrentValue=State.HitboxSize, Callback=function(v) State.HitboxSize=v end})
local HitboxColorPicker = CombatTab:CreateColorPicker({Name="Hitbox Color", Color=State.HitboxColor, Callback=function(v) State.HitboxColor=v end})

-- Self-hand hitbox controls
local SelfHandToggle = CombatTab:CreateToggle({Name="Self Hand Hitbox", CurrentValue=State.SelfHandHitbox, Callback=function(v) State.SelfHandHitbox=v end})
local HandSelect = CombatTab:CreateDropdown({Name="Hand Target", Options={"Both","Right","Left"}, CurrentOption=State.HandTarget, Callback=function(v) State.HandTarget=v end})
local HandSizeSlider = CombatTab:CreateSlider({Name="Hand Hitbox Size", Range={1,50}, Increment=1, CurrentValue=State.HandHitboxSize, Callback=function(v) State.HandHitboxSize=v end})

-- Movement
MoveTab:CreateSlider({Name="WalkSpeed", Range={16,200}, Increment=1, CurrentValue=State.WalkSpeed, Callback=function(v) State.WalkSpeed=v end})
MoveTab:CreateSlider({Name="JumpPower", Range={50,300}, Increment=1, CurrentValue=State.JumpPower, Callback=function(v) State.JumpPower=v end})
local FlyToggle = MoveTab:CreateToggle({Name="Fly", CurrentValue=State.Fly, Callback=function(v) State.Fly=v end})
MoveTab:CreateSlider({Name="Fly Speed", Range={10,200}, Increment=1, CurrentValue=State.FlySpeed, Callback=function(v) State.FlySpeed=v end})
local NoClipToggle = MoveTab:CreateToggle({Name="NoClip", CurrentValue=State.NoClip, Callback=function(v) State.NoClip=v end})

-- ESP / Misc
local ESPEnableToggle = ESPTab:CreateToggle({Name="Enable ESP", CurrentValue=State.ESP, Callback=function(v) State.ESP=v end})
local TargetESPToggle = ESPTab:CreateToggle({Name="Target ESP", CurrentValue=State.TargetESP, Callback=function(v) State.TargetESP=v end})
local ESPColorPicker = ESPTab:CreateColorPicker({Name="ESP Color", Color=State.ESPColor, Callback=function(v) State.ESPColor=v end})
local InvisibleToggle = MiscTab:CreateToggle({Name="Invisible", CurrentValue=State.Invisible, Callback=function(v) State.Invisible=v end})

-- GUI Hotkey
UIS.InputBegan:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.RightShift then Window:Toggle() end end)

-- ================= Movement Implementation (Fly improved) =================
-- We'll create BodyVelocity+BodyGyro on character when Fly enabled, and remove when disabled.
local FlyControllers = {} -- [char] = {bv,bg}
local function enableFly(char)
    if not char or FlyControllers[char] then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local bv = Instance.new("BodyVelocity")
    bv.Name = "COCO_HUB_Fly_BV"
    bv.MaxForce = Vector3.new(1e5,1e5,1e5)
    bv.P = 1250
    bv.Velocity = Vector3.new(0,0,0)
    bv.Parent = hrp
    local bg = Instance.new("BodyGyro")
    bg.Name = "COCO_HUB_Fly_BG"
    bg.MaxTorque = Vector3.new(1e5,1e5,1e5)
    bg.P = 3000
    bg.CFrame = hrp.CFrame
    bg.Parent = hrp
    FlyControllers[char] = {BV=bv,BG=bg}
end
local function disableFly(char)
    if not char or not FlyControllers[char] then return end
    pcall(function()
        local t = FlyControllers[char]
        if t.BV then t.BV:Destroy() end
        if t.BG then t.BG:Destroy() end
    end)
    FlyControllers[char] = nil
end

-- Apply Movement each frame
RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        pcall(function() hum.WalkSpeed = State.WalkSpeed; hum.JumpPower = State.JumpPower end)
    end

    -- Fly enable/disable per-character
    if State.Fly then
        enableFly(char)
        local ctrl = FlyControllers[char]
        if ctrl and ctrl.BV then
            -- compute desired direction
            local camCF = Workspace.CurrentCamera.CFrame
            local dir = Vector3.new()
            if UIS:IsKeyDown(Enum.KeyCode.W) then dir = dir + camCF.LookVector end
            if UIS:IsKeyDown(Enum.KeyCode.S) then dir = dir - camCF.LookVector end
            if UIS:IsKeyDown(Enum.KeyCode.A) then dir = dir - camCF.RightVector end
            if UIS:IsKeyDown(Enum.KeyCode.D) then dir = dir + camCF.RightVector end
            if UIS:IsKeyDown(Enum.KeyCode.Space) then dir = dir + Vector3.new(0,1,0) end
            if UIS:IsKeyDown(Enum.KeyCode.LeftControl) then dir = dir - Vector3.new(0,1,0) end
            if dir.Magnitude > 0 then
                ctrl.BV.Velocity = dir.Unit * State.FlySpeed
                ctrl.BG.CFrame = Camera.CFrame
            else
                ctrl.BV.Velocity = Vector3.new(0,0,0)
            end
        end
    else
        disableFly(char)
    end

    -- NoClip (local only)
    if State.NoClip then
        for _,part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function() part.CanCollide = false end)
            end
        end
    end
end)

-- make sure controllers removed on character removing
LocalPlayer.CharacterRemoving:Connect(function(ch)
    disableFly(ch)
    restoreOriginalHandSizes(ch)
end)

-- ================= Invisible =================
local InvisibleStore = {}
local function applyInvisible(char)
    if not char or InvisibleStore[char] then return end
    InvisibleStore[char] = {}
    for _, part in pairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            InvisibleStore[char][part] = {Transparency = part.Transparency, CanCollide = part.CanCollide}
            pcall(function() part.Transparency = 1; part.CanCollide = false end)
        elseif part:IsA("Accessory") then
            local handle = part:FindFirstChildWhichIsA("BasePart")
            if handle then
                InvisibleStore[char][handle] = {Transparency = handle.Transparency, CanCollide = handle.CanCollide}
                pcall(function() handle.Transparency = 1; handle.CanCollide = false end)
            end
        end
    end
end
local function restoreInvisible(char)
    if not char or not InvisibleStore[char] then return end
    for part, props in pairs(InvisibleStore[char]) do
        if part and part.Parent then
            pcall(function() part.Transparency = props.Transparency; part.CanCollide = props.CanCollide end)
        end
    end
    InvisibleStore[char] = nil
end
RunService.Heartbeat:Connect(function()
    if State.Invisible then
        if LocalPlayer.Character then applyInvisible(LocalPlayer.Character) end
    else
        if LocalPlayer.Character then restoreInvisible(LocalPlayer.Character) end
    end
end)
LocalPlayer.CharacterAdded:Connect(function(ch)
    if State.Invisible then applyInvisible(ch) end
end)

-- ================= ESP / FOV / Targeting =================
local ESPObjects = {}
local FOVCircle = safeDrawing.available and newDrawing("Circle",{Color=Color3.fromRGB(0,255,255),Thickness=2,Filled=false,Visible=false,Radius=State.FOVRadius}) or nil

local function worldToScreenVec(pos)
    local x,y,z = Camera:WorldToViewportPoint(pos)
    return Vector2.new(x,y), z>0
end

-- store existing players' originals
for _,plr in pairs(Players:GetPlayers()) do
    if plr.Character then storeOriginalHitbox(plr); storeOriginalHandSizes(plr.Character) end
end
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function(ch)
        ch:WaitForChild("HumanoidRootPart",5)
        storeOriginalHitbox(plr)
    end)
end)

local CurrentTarget = nil
local function GetBestTarget()
    local vw,vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    local best = State.FOVRadius
    local bestP = nil
    for _,p in pairs(Players:GetPlayers()) do
        if p~=LocalPlayer and p.Character and p.Character:FindFirstChild(State.AimbotPart) then
            local hum = p.Character:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health>0 then
                local pos3 = p.Character[State.AimbotPart].Position
                local sp,onScreen = Camera:WorldToViewportPoint(pos3)
                if onScreen then
                    local d = (Vector2.new(sp.X,sp.Y)-Vector2.new(vw/2,vh/2)).Magnitude
                    if d < best then best = d; bestP = p end
                end
            end
        end
    end
    return bestP
end

-- Main loop for ESP / Hitbox / FOV / Self hand hitbox
RunService.RenderStepped:Connect(function()
    -- Hitbox for others
    if State.Hitbox then
        for _,p in pairs(Players:GetPlayers()) do
            if p~=LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = p.Character:FindFirstChild("HumanoidRootPart")
                storeOriginalHitbox(p)
                pcall(function() hrp.Size = Vector3.new(State.HitboxSize, State.HitboxSize, State.HitboxSize); hrp.CanCollide = false end)
            end
        end
    end

    -- Acquire target
    if State.Aimbot or State.SilentAim then CurrentTarget = GetBestTarget() else CurrentTarget = nil end

    -- FOV circle visible only when aiming
    if FOVCircle then
        if State.Aimbot or State.SilentAim then
            FOVCircle.Visible = true
            pcall(function()
                FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                FOVCircle.Radius = State.FOVRadius
                FOVCircle.Color = State.FOVRainbow and Color3.fromHSV((tick()%5)/5,1,1) or Color3.fromRGB(0,255,255)
            end)
        else
            pcall(function() FOVCircle.Visible = false end)
        end
    end

    -- Self Hand Hitbox: expand user's own hand parts
    if State.SelfHandHitbox and LocalPlayer.Character then
        local ch = LocalPlayer.Character
        storeOriginalHandSizes(ch)
        local info = OriginalHandSizes[ch]
        -- decide which hands to affect
        local doRight = (State.HandTarget=="Both" or State.HandTarget=="Right")
        local doLeft  = (State.HandTarget=="Both" or State.HandTarget=="Left")
        -- right
        if doRight and info and info.RightName and ch:FindFirstChild(info.RightName) and ch[info.RightName]:IsA("BasePart") then
            local part = ch[info.RightName]
            pcall(function() part.Size = Vector3.new(State.HandHitboxSize, State.HandHitboxSize, State.HandHitboxSize); part.CanCollide = false end)
        end
        -- left
        if doLeft and info and info.LeftName and ch:FindFirstChild(info.LeftName) and ch[info.LeftName]:IsA("BasePart") then
            local part = ch[info.LeftName]
            pcall(function() part.Size = Vector3.new(State.HandHitboxSize, State.HandHitboxSize, State.HandHitboxSize); part.CanCollide = false end)
        end
    else
        -- restore when disabled
        if LocalPlayer.Character and OriginalHandSizes[LocalPlayer.Character] then
            restoreOriginalHandSizes(LocalPlayer.Character)
        end
    end

    -- ESP drawing
    if safeDrawing.available and State.ESP then
        for _,p in pairs(Players:GetPlayers()) do
            if p~=LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = p.Character:FindFirstChild("HumanoidRootPart")
                local hum = p.Character:FindFirstChildOfClass("Humanoid")
                if not ESPObjects[p] then
                    ESPObjects[p] = {
                        Outline = newDrawing("Square",{Color=State.ESPColor,Thickness=2,Filled=false,Visible=false}),
                        Text = newDrawing("Text",{Text="",Color=State.ESPColor,Size=14,Center=true,Visible=false})
                    }
                end
                local box = ESPObjects[p]
                if hrp and hum then
                    local scr,onScreen = worldToScreenVec(hrp.Position)
                    if onScreen then
                        pcall(function()
                            local sizeX,sizeY = 40,80
                            box.Outline.Position = Vector2.new(scr.X - sizeX/2, scr.Y - sizeY/2)
                            box.Outline.Size = Vector2.new(sizeX,sizeY)
                            box.Outline.Color = State.ESPColor
                            box.Outline.Visible = true
                            box.Text.Position = Vector2.new(scr.X, scr.Y - sizeY/2 - 10)
                            box.Text.Text = "HP: "..math.floor(hum.Health).."/"..math.floor(hum.MaxHealth)
                            box.Text.Color = State.ESPColor
                            box.Text.Visible = true
                            if State.TargetESP and CurrentTarget == p then
                                box.Outline.Color = Color3.fromRGB(0,255,0)
                                box.Text.Color = Color3.fromRGB(0,255,0)
                            end
                        end)
                    else
                        pcall(function() box.Outline.Visible=false; box.Text.Visible=false end)
                    end
                end
            else
                if ESPObjects[p] then pcall(function() if ESPObjects[p].Outline then ESPObjects[p].Outline.Visible=false end; if ESPObjects[p].Text then ESPObjects[p].Text.Visible=false end end) end
            end
        end
    else
        -- hide all ESP drawings if disabled
        for plr,draw in pairs(ESPObjects) do
            pcall(function() if draw.Outline then draw.Outline.Visible=false end; if draw.Text then draw.Text.Visible=false end end)
        end
    end
end)

-- Clean up on player leaving
Players.PlayerRemoving:Connect(function(plr)
    if ESPObjects[plr] then pcall(function() if ESPObjects[plr].Outline then ESPObjects[plr].Outline.Visible=false end; if ESPObjects[plr].Text then ESPObjects[plr].Text.Visible=false end end) end
    restoreOriginalHitbox(plr)
end)

-- ================= Aimbot / SilentAim =================
-- Auto Aim (Camera-Lock) for normal Aimbot
RunService.RenderStepped:Connect(function()
    if State.Aimbot and CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild(State.AimbotPart) then
        local targetPart = CurrentTarget.Character[State.AimbotPart]
        if targetPart then
            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local camCF = Camera.CFrame
                local targetPos = targetPart.Position
                local direction = (targetPos - camCF.Position).Unit
                Camera.CFrame = CFrame.new(camCF.Position, camCF.Position + direction)
            end
        end
    end
end)

-- Silent Aim / Bullet Redirect
do
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt,false)

    mt.__namecall = newcclosure(function(self,...)
        local args = {...}
        local method = getnamecallmethod()
        
        if State.SilentAim and CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild(State.AimbotPart) then
            -- Adjust bullet target for RemoteEvents
            if method == "FireServer" and typeof(self)=="Instance" and self.Name:lower():find("fire") then
                -- assume first argument is target position
                local targetPart = CurrentTarget.Character[State.AimbotPart]
                if targetPart then
                    args[1] = targetPart.Position
                    return oldNamecall(self, unpack(args))
                end
            end
        end
        return oldNamecall(self,...)
    end)

    setreadonly(mt,true)
end

-- AutoShoot (for standard Aimbot)
RunService.RenderStepped:Connect(function()
    if State.Aimbot and CurrentTarget then
        -- simple example: Fire your tool if equipped
        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if tool and tool:FindFirstChild("Remote") then
            pcall(function() tool.Remote:FireServer(CurrentTarget.Character[State.AimbotPart].Position) end)
        end
    end
end)

